# 捕获信号(trap)
```bash
###trap格式
trap commands signals

$ cat trapsignal.sh
#!/bin/bash
#Testing signal trapping
#
###捕获到SIGINT信号时只执行echo命令
trap "echo ' Sorry! I have trapped Ctrl-C'" SIGINT
#
echo This is a test script.
#
count=1
while [ $count -le 5 ]
do
     echo "Loop #$count"
     sleep 1
     count=$[ $count + 1 ]
done
#
echo "This is the end of test script."
exit
$ ./trapsignal.sh
This is a test script.
Loop #1
Loop #2
^C Sorry! I have trapped Ctrl-C
Loop #3
^C Sorry! I have trapped Ctrl-C
Loop #4
Loop #5
This is the end of test script.
$


###使用带有空操作命令的trap使用带有空操作命令的trap可以保证脚本中的关键操作不被打断
trap "" SIGINT 
```
## 捕获脚本退出
```bash
$ cat trapexit.sh
#!/bin/bash
#Testing exit trapping
#
###捕获到EXIT信息时执行命令
trap "echo Goodbye..." EXIT
#
count=1
while [ $count -le 5 ]
do
     echo "Loop #$count"
     sleep 1
     count=$[ $count + 1 ]
done
#
exit
$
$ ./trapexit.sh
Loop #1
Loop #2
Loop #3
Loop #4
Loop #5
Goodbye...
$
```
## 修改或移除信号捕获
```bash
$ cat trapmod.sh
#!/bin/bash
#Modifying a set trap
#
###第一次定义捕获信号执行的命令
trap "echo ' Sorry...Ctrl-C is trapped.'" SIGINT
#
count=1
while [ $count -le 3 ]
do
     echo "Loop #$count"
     sleep 1
     count=$[ $count + 1 ]
done
#
###重新定义捕获信号后执行的命令
trap "echo ' I have modified the trap!'" SIGINT
#
count=1
while [ $count -le 3 ]
do
     echo "Second Loop #$count"
     sleep 1
     count=$[ $count + 1 ]
done
#
###移除掉信号捕获
trap -- SIGINT
echo "The trap is now removed."
#
count=1
while [ $count -le 3 ]
do
     echo "Second Loop #$count"
     sleep 1
     count=$[ $count + 1 ]
done
#
exit

$
```
## 后台运行脚本
```bash
./backgroundscript.sh &
!!!注意: 每一个后台进程都和终端会话（pts/0）终端关联在一起, 如果终端会话退出，那么后台进程也会随之退出。
```
## 